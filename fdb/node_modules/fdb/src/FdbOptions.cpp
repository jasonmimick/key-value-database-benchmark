/*
 * FoundationDB Node.js API
 * Copyright (c) 2012 FoundationDB, LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include "FdbOptions.h"
#include "Cluster.h"
#include "Database.h"
#include "Transaction.h"
#include "FdbError.h"

#include <algorithm>
#include <node_buffer.h>

#define INVALID_OPTION_VALUE_ERROR_CODE (fdb_error_t)2006

using namespace v8;
using namespace node;

Persistent<FunctionTemplate> FdbOptions::networkOptionsTemplate;
Persistent<FunctionTemplate> FdbOptions::clusterOptionsTemplate;
Persistent<FunctionTemplate> FdbOptions::databaseOptionsTemplate;
Persistent<FunctionTemplate> FdbOptions::transactionOptionsTemplate;
Persistent<FunctionTemplate> FdbOptions::streamingModeTemplate;
Persistent<FunctionTemplate> FdbOptions::atomicOperationsTemplate;

FdbOptions::FdbOptions() { }

void FdbOptions::InitOptionsTemplate(Persistent<FunctionTemplate> &tpl, const char *className) {
	tpl = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
	tpl->SetClassName(String::NewSymbol(className));
	tpl->InstanceTemplate()->SetInternalFieldCount(1);
}

void FdbOptions::Init() {
	InitOptionsTemplate(networkOptionsTemplate, "FdbNetworkOptions");
	InitOptionsTemplate(clusterOptionsTemplate, "FdbClusterOptions");
	InitOptionsTemplate(databaseOptionsTemplate, "FdbDatabaseOptions");
	InitOptionsTemplate(transactionOptionsTemplate, "FdbTransactionOptions");
	InitOptionsTemplate(streamingModeTemplate, "FdbStreamingMode");
	InitOptionsTemplate(atomicOperationsTemplate, "AtomicOperations");

	InitOptions();
}

Handle<Value> FdbOptions::New(const Arguments &args) {
	FdbOptions *options = new FdbOptions();
	options->Wrap(args.Holder());

	return args.Holder();
}

void FdbOptions::WeakCallback(Persistent<Value> value, void *data) { }

Handle<Value> FdbOptions::NewInstance(Persistent<FunctionTemplate> optionsTemplate, Handle<Value> source) {
	HandleScope scope;

	Local<Object> instance = optionsTemplate->GetFunction()->NewInstance();

	FdbOptions *optionsObj = ObjectWrap::Unwrap<FdbOptions>(instance);
	optionsObj->source = Persistent<Value>::New(source);
	optionsObj->source.MakeWeak(optionsObj, WeakCallback);

	return scope.Close(instance);
}

Handle<Value> FdbOptions::CreateNetworkOptions() {
	return NewInstance(networkOptionsTemplate, Null());
}

Handle<Value> FdbOptions::CreateClusterOptions(Handle<Value> cluster) {
	return NewInstance(clusterOptionsTemplate, cluster);
}

Handle<Value> FdbOptions::CreateDatabaseOptions(Handle<Value> database) {
	return NewInstance(databaseOptionsTemplate, database);
}

Handle<Value> FdbOptions::CreateTransactionOptions(Handle<Value> transaction) {
	return NewInstance(transactionOptionsTemplate, transaction);
}

Handle<Value> FdbOptions::CreateAtomicOperations() {
	return NewInstance(atomicOperationsTemplate, Null());
}

Handle<Value> FdbOptions::CreateStreamingModes() {
	return streamingModeTemplate->GetFunction()->NewInstance();
}

struct Parameter {
	Parameter() : isNull(true), errorCode(0) { }
	Parameter(std::string param) : param(param), isNull(false), errorCode(0) { }
	Parameter(fdb_error_t errorCode) : isNull(false), errorCode(errorCode) { }

	std::string param;
	bool isNull;
	fdb_error_t errorCode;

	uint8_t const* getValue() { return isNull ? NULL : (uint8_t const*)param.c_str(); }
	int getLength() { return isNull ? 0 : param.size(); }
};

Parameter getStringParameter(const Arguments &args, int index) {
	if(args.Length() <= index || (!Buffer::HasInstance(args[index]) && !args[index]->IsString()))
		return INVALID_OPTION_VALUE_ERROR_CODE;
	else if(args[index]->IsString()) {
		String::Utf8Value val(args[index]);
		return std::string(*val, val.length());
	}
	else
		return std::string(Buffer::Data(args[index]->ToObject()), Buffer::Length(args[index]->ToObject()));
};

Parameter getOptionParameter(const Arguments &args, int optionValue, std::map<int, FdbOptions::ParameterType> &parameterTypes) {
	if(args.Length() > 0) {
		int64_t val;
		switch(parameterTypes[optionValue]) {
			case FdbOptions::String:
				return getStringParameter(args, 0);

			case FdbOptions::Bytes:
				if(!Buffer::HasInstance(args[0]))
					return INVALID_OPTION_VALUE_ERROR_CODE;

				return std::string(Buffer::Data(args[0]->ToObject()), Buffer::Length(args[0]->ToObject()));

			case FdbOptions::Int:
				if(!args[0]->IsNumber())
					return INVALID_OPTION_VALUE_ERROR_CODE;
				val = args[0]->IntegerValue();
				return std::string((const char*)&val, 8);

			
			case FdbOptions::None:
				return Parameter();
		}
	}

	return Parameter();
}

v8::Handle<v8::Value> FdbOptions::SetNetworkOption(const Arguments &args) {
	FDBNetworkOption op = (FDBNetworkOption)args.Data()->Uint32Value();

	Parameter param = getOptionParameter(args, op, networkParameterTypes);
	fdb_error_t errorCode = param.errorCode;
	if(errorCode == 0)
		errorCode = fdb_network_set_option(op, param.getValue(), param.getLength());

	if(errorCode)
		return ThrowException(FdbError::NewInstance(errorCode, fdb_get_error(errorCode)));

	return Null();
}

v8::Handle<v8::Value> FdbOptions::SetClusterOption(const Arguments &args) {
	FdbOptions *options = ObjectWrap::Unwrap<FdbOptions>(args.Holder());
	Cluster *cluster = ObjectWrap::Unwrap<Cluster>(options->source->ToObject());
	FDBClusterOption op = (FDBClusterOption)args.Data()->Uint32Value();

	Parameter param = getOptionParameter(args, op, clusterParameterTypes);
	fdb_error_t errorCode = param.errorCode;
	if(errorCode == 0)
		errorCode = fdb_cluster_set_option(cluster->GetCluster(), op, param.getValue(), param.getLength());

	if(errorCode)
		return ThrowException(FdbError::NewInstance(errorCode, fdb_get_error(errorCode)));

	return Null();
}

v8::Handle<v8::Value> FdbOptions::SetDatabaseOption(const Arguments &args) {
	FdbOptions *options = ObjectWrap::Unwrap<FdbOptions>(args.Holder());
	Database *db = ObjectWrap::Unwrap<Database>(options->source->ToObject());
	FDBDatabaseOption op = (FDBDatabaseOption)args.Data()->Uint32Value();

	Parameter param = getOptionParameter(args, op, databaseParameterTypes);
	fdb_error_t errorCode = param.errorCode;
	if(errorCode == 0)
		errorCode = fdb_database_set_option(db->GetDatabase(), op, param.getValue(), param.getLength());

	if(errorCode)
		return ThrowException(FdbError::NewInstance(errorCode, fdb_get_error(errorCode)));

	return Null();
}

v8::Handle<v8::Value> FdbOptions::SetTransactionOption(const Arguments &args) {
	FdbOptions *options = ObjectWrap::Unwrap<FdbOptions>(args.Holder());
	Transaction *tr = ObjectWrap::Unwrap<Transaction>(options->source->ToObject());
	FDBTransactionOption op = (FDBTransactionOption)args.Data()->Uint32Value();

	Parameter param = getOptionParameter(args, op, transactionParameterTypes);
	fdb_error_t errorCode = param.errorCode;
	if(errorCode == 0)
		errorCode = fdb_transaction_set_option(tr->GetTransaction(), op, param.getValue(), param.getLength());

	if(errorCode)
		return ThrowException(FdbError::NewInstance(errorCode, fdb_get_error(errorCode)));

	return Null();
}

v8::Handle<v8::Value> FdbOptions::CallAtomicOperation(const Arguments &args) {
	Transaction *tr = ObjectWrap::Unwrap<Transaction>(args.Holder());
	Parameter key = getStringParameter(args, 0);
	Parameter value = getStringParameter(args, 1);

	fdb_error_t errorCode = key.errorCode > 0 ? key.errorCode : value.errorCode;
	if(errorCode > 0)
		return ThrowException(FdbError::NewInstance(errorCode, fdb_get_error(errorCode)));

	fdb_transaction_atomic_op(tr->GetTransaction(), key.getValue(), key.getLength(), value.getValue(), value.getLength(), (FDBMutationType)args.Data()->Uint32Value());

	return Null();
}

//Converts names using underscores as word separators to camel case (but preserves existing capitalization, if present). If isSetter, prepends the word 'set' to each name
std::string FdbOptions::ToJavaScriptName(std::string optionName, bool isSetter) {
	if(isSetter)
		optionName = "set_" + optionName;

	size_t start = 0;
	while(start < optionName.size()) {
		if(start != 0)
			optionName[start] = ::toupper(optionName[start]);
		size_t index = optionName.find_first_of('_', start);
		if(index == std::string::npos)
			break;

		optionName.erase(optionName.begin() + index);

		start = index;
	}

	return optionName;
}

std::map<int, FdbOptions::ParameterType> FdbOptions::networkParameterTypes;
std::map<int, FdbOptions::ParameterType> FdbOptions::clusterParameterTypes;
std::map<int, FdbOptions::ParameterType> FdbOptions::databaseParameterTypes;
std::map<int, FdbOptions::ParameterType> FdbOptions::transactionParameterTypes;
